

//
//  main.cpp
//  Binary Search Trees
//

#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>

#include "SearchTree.h"
#include "AVLTree.h"
#include "sort2.h"

using std::cout;
using std::endl;

using std::string;
using std::to_string;
using std::vector;
using std::swap;
using std::find;


// #includes and declarations for repeatable random seed
#include <random>
#include <cassert>
using SeedType = std::random_device::result_type; // Seed type for random number generator
using RandGen = std::default_random_engine; // Type for random number generator
constexpr auto NEW_SEED_ARG = "newseed";
constexpr auto seedName = "SEED.txt"; // Filename to hold most recent seed
SeedType getSeed(int, const char* []);


/*
 Get the seed for the random number generator

 The last seed is stored in the file named in seedName. If that file
 exists and seedOption is not "new", use that value again. This
 will repeat the random sequence used in the last run.
 
 If that file does not exist or it exists but if the command line
 Argument 1 is "new", use a fresh seed generated by std::random_device.
*/
SeedType getSeed(int argc, const char* argv[]) {
    bool forceNew {}; // True == force a new seed
    if (argc < 2)
        forceNew = false;
    else
        forceNew = string(argv[1]) == NEW_SEED_ARG;
    
    auto seed = std::random_device()(); // Fresh seed
    
    // Select fresh seed or last seed, as necessary
    std::ifstream seedIn{seedName};
    if (seedIn) { // File exists
        if (forceNew) {
           cout << "New seed " << seed << endl << endl;
        }
        else { // Reuse seed from file
            seedIn >> seed;
            cout << "Reusing seed " << seed << endl << endl;
        }
        seedIn.close();
    }
    else
       cout << "Creating first seed " << seed << endl << endl;
    
    // Save the chosen seed
    std::ofstream seedOut{seedName, std::ios_base::trunc | std::ios_base::out};
    assert(seedOut);
    seedOut << seed;
    seedOut.close();
    return seed;
}

//chose insertion sort since it was easiest to modify from original code
int insertionSort(Container& arr, Iter start, Iter end)
{
	int count=0;
	
	for (Iter i=start; i<end;i++)
        {
	Iter j=i;
		
                while(j>0 && arr[j]<arr[j-1])
        	{
		
			swap(arr[j],arr[j-1]);
			j--;
		}
		count++;
 
	}
	return count;
}

/*
 Print the (key, value) pairs in the tree according to the order
 provided by the tree's iterator.
 */
void printValues(const SearchTree& st, const  string& name) {
    cout << "Tree " << name << " size " <<  st.size() << '\n';
    for (const auto& p : st) {
        cout << p << " ";
    }
    cout << '\n';
}

int main(int argc, const char* argv[]) {

vector<int> n {50,100,500,1000,5000,10000,25000}; //had to use small upper bound because of memory issues

for (auto sz = n.begin(); sz != n.end(); sz++)
{
    // Set the seed for the random number generator
    SeedType seed {getSeed(argc, argv)};
    RandGen rand{seed};
    int size=*sz;
    cout<<"for SIZE="<<size<<endl;
    
    vector<int> vec;
    int maxv=size*100;
    int value;
    string s;
     
    while(vec.size()!=size)
    {
        value=rand() % maxv;
        if(find(vec.begin(),vec.end(),value)==vec.end())
        {
              vec.push_back(value);
        }
    }
    
/*
    for (auto it = vec.begin(); it != vec.end(); it++)
    {
        cout << *it  << " ";
    }*/
    cout<<endl;
    cout<<"for RANDOM data: "<<endl;
   /* cout<<"Worst case ST tree: "<<endl;*/

    SearchTree st_Worst{};

    for (auto it = vec.begin(); it != vec.end(); it++)
    {
       st_Worst.insert(*it, to_string(*it));
    }
 /*  
    st_Worst.debugPrintTree(cout, "worst case st");
    cout << endl;

    printValues(st_Worst, "worst case ST pairs in iterator order");
    cout << endl;
   */
    int num1=st_Worst.getComparisons();
    cout<<"comparison count for worst case ST: "<<num1<<endl;
    cout<<endl;
   
    cout<<"worst case AVL tree: "<<endl;
    AVLTree avl_Worst{};
   
    for (auto it = vec.begin(); it != vec.end(); it++)
    {
       avl_Worst.insert(*it, to_string(*it));
    }
 /*   
    avl_Worst.debugPrintTree(cout, "worst case AVL");
    cout << endl;

    printValues(avl_Worst, "worst case AVL pairs in iterator order");
    cout << endl;
*/
    int num2=avl_Worst.getComparisons();
    cout<<"comparison count for worst case AVL: "<<num2<<endl;
    cout<<endl;

    cout<<"for SORTED data"<<endl;

    insertionSort(vec,0,vec.size());
/*
    for (auto it = vec.begin(); it != vec.end(); it++)
    {
        cout << *it  << " ";
    }*/
    cout<<endl;
    
    SearchTree st_Worst2{};

    
    for (auto it = vec.begin(); it != vec.end(); it++)
    {
       st_Worst2.insert(*it, to_string(*it));
    }
/*
    st_Worst2.debugPrintTree(cout, "worst case st");
    cout << endl;

    printValues(st_Worst2, "worst case ST pairs in iterator order");
    cout << endl;
  */  
    int num3=st_Worst2.getComparisons();
    cout<<"comparison count for worst case sorted ST: "<<num3<<endl;
    cout<<endl;

    cout<<"worst case AVL tree: "<<endl;
    AVLTree avl_Worst2{};
    
    for (auto it = vec.begin(); it != vec.end(); it++)
    {
       avl_Worst2.insert(*it, to_string(*it));
    }
  /*
    avl_Worst2.debugPrintTree(cout, "worst case AVL");
    cout << endl;

    printValues(avl_Worst2, "worst case AVL pairs in iterator order");
    cout << endl;
*/
    int num4=avl_Worst2.getComparisons();
    cout<<"comparison count for worst case sorted AVL: "<<num4<<endl;
    cout<<endl;
}

cout<<"end"<<endl;
    return 0;
    
}


